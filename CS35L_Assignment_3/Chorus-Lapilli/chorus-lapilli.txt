I have started working on top of the code created for tic-tac-toe. I reused the grid, and the Board function but added parameters for it to communicate properly with the variables in Game. 
This was done after troubleshooting errors regarding the Board not able to receive the current game state and thus not being able to perform correctly. 
The initial pseudocode was written to help understand the logic in my head. I have not found any ‘softlock’ states which would cause the game to be stuck in an immovable state or in a state of not being able to end in a victory of one side.
So it was deemed unnecessary to add measures to counteract such states. The calculateWinner is reused and the normal tic-tac-toe game is reused until we reach move 6. 
From move 7, the hasSelected and selectedSquare is used to store the initial click before moving onto the desired destination. It checks xIsNext to find which player’s turn it is, and checks if the initial clicked square has the same mark. 
If it does not match or is empty, the click is not considered saved, and outputs an error via the console. If the click is a valid choice, its index is saved the selectedSquare and the state hasSelected is updated to reflect this action. 
The next click which selects the destination of our ‘move’ is then fed into moveValid which checks if the action we want to perform is a legal move. If the move is illegal, the selectedSquare is reverted to null and hasSelected is set back to false to allow the user to select another square(This is also necessary as if it was not possible to change the selected square, if you do not abide the center square clause, it could end up in a softlock). 
If the move is legal, the original selected square value is changed to null and the turn player’s mark is placed on the latter selected square. The appropriate message that shows what move was made is output to the console. All the appropriate states are added to the Board and its input declaration.
I noticed the necessary rule after making the chorus-lapilli game without the center square clause. This code was later edited to add that functionality. The original handleClick after move 6 only considered moveValid to account for the move being adjacent and destination square being empty. 
However, the centerClause was later added to implement the rule of the center square needing to be evacuated unless the next move is a winning move.
